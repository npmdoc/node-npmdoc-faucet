<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/substack/faucet"

    >faucet (v0.0.1)</a>
</h1>
<h4>human-readable TAP summarizer</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.faucet">module faucet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.faucet.faucet">
            function <span class="apidocSignatureSpan"></span>faucet
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.faucet" id="apidoc.module.faucet">module faucet</a></h1>


    <h2>
        <a href="#apidoc.element.faucet.faucet" id="apidoc.element.faucet.faucet">
        function <span class="apidocSignatureSpan"></span>faucet
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">faucet = function (opts) {
    if (!opts) opts = {};
    var tap = parser();
    var out = through2();
    var test, lastAssert;

    tap.on(&#x27;comment&#x27;, function (comment) {
        if (comment === &#x27;fail 0&#x27;) return; // a mocha thing

        if (test &#x26;&#x26; test.ok &#x26;&#x26; test.assertions.length === 0
        &#x26;&#x26; /^(tests|pass)\s+\d+$/.test(test.name)) {
            out.push(&#x27;\r&#x27; + trim(test.name));
        }
        else if (test &#x26;&#x26; test.ok) {
            var s = updateName(test.offset + 1, &#x27;✓ &#x27; + test.name, 32);
            out.push(&#x27;\r&#x27; + s);
        }

        test = {
            name: comment,
            assertions: [],
            offset: 0,
            ok: true
        };
        out.push(&#x27;\r&#x27; + trim(&#x27;# &#x27; + comment) + &#x27;\x1b[K\n&#x27;);
    });

    tap.on(&#x27;assert&#x27;, function (res) {
        var ok = res.ok ? &#x27;ok&#x27; : &#x27;not ok&#x27;;
        var c = res.ok ? 32 : 31;
        if (!test) {
            // mocha produces TAP results this way, whatever
            var s = trim(res.name.trim());
            out.push(sprintf(
                &#x27;\x1b[1m\x1b[&#x27; + c + &#x27;m%s\x1b[0m\n&#x27;,
                trim((res.ok ? &#x27;✓&#x27; : &#x27;⨯&#x27;) + &#x27; &#x27; +  s)
            ));
            return;
        }

        var fmt = &#x27;\r  %s \x1b[1m\x1b[&#x27; + c + &#x27;m%d\x1b[0m %s\x1b[K&#x27;;
        var str = sprintf(fmt, ok, res.number, res.name);

        if (!res.ok) {
            var y = (++ test.offset) + 1;
            str += &#x27;\n&#x27;;
            if (test.ok) {
                str += updateName(y, &#x27;⨯ &#x27; + test.name, 31)
            }
            test.ok = false;
        }
        out.push(str);
        test.assertions.push(res);
    });

    tap.on(&#x27;extra&#x27;, function (extra) {
        if (!test || test.assertions.length === 0) return;
        var last = test.assertions[test.assertions.length-1];
        if (!last.ok) {
            out.push(extra.split(&#x27;\n&#x27;).map(function (line) {
                return &#x27;  &#x27; + line;
            }).join(&#x27;\n&#x27;) + &#x27;\n&#x27;);
        }
    });

    tap.on(&#x27;results&#x27;, function (res) {
        if (test &#x26;&#x26; /^fail\s+\d+$/.test(test.name)) {
            out.push(updateName(test.offset + 1, &#x27;⨯ &#x27; + test.name, 31));
        }
        else if (test &#x26;&#x26; test.ok) {
            out.push(updateName(test.offset + 1, &#x27;✓ &#x27; + test.name, 32));
        }

        res.errors.forEach(function (err, ix) {
            out.push(sprintf(
                &#x27;not ok \x1b[1m\x1b[31m%d\x1b[0m %s\n&#x27;,
                ix + 1 + res.asserts.length, err.message
            ));
        });

        if (!res.ok &#x26;&#x26; !/^fail\s+\d+$/.test(test &#x26;&#x26; test.name)) {
            out.push(sprintf(
                &#x27;\r\x1b[1m\x1b[31m⨯ fail  %s\x1b[0m\x1b[K\n&#x27;,
                (res.errors.length + res.fail.length) || &#x27;&#x27;
            ));
        }

        out.push(null);

        dup.emit(&#x27;results&#x27;, res);
        if (!res.ok) dup.emit(&#x27;fail&#x27;);
        dup.exitCode = res.ok ? 0 : 1;
    });

    var dup = duplexer(tap, out);
    return dup;

    function showTest (test) {
        out.push(&#x27;\r&#x27;);
    }

    function trim (s) {
        if (opts.width &#x26;&#x26; s.length &#x3e; opts.width - 2) {
            s = s.slice(0, opts.width - 5) + &#x27;...&#x27;;
        }
        return s;
    }

    function updateName (y, str, c) {
        return &#x27;\x1b[&#x27; + y + &#x27;A&#x27;
            + &#x27;\x1b[1G&#x27;
            + &#x27;\x1b[1m\x1b[&#x27; + c + &#x27;m&#x27;
            + trim(str)
            + &#x27;\x1b[0m&#x27;
            + &#x27;\x1b[&#x27; + y + &#x27;B\x1b[1G&#x27;
        ;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
